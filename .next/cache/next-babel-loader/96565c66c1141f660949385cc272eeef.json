{"ast":null,"code":"import { cloneDeep } from 'lodash';\nimport * as pathToRegexp from 'path-to-regexp';\nimport { authService } from '@services/index';\n/**\n * Convert an array to a tree-structured array.\n * @param   {array}     array     The Array need to Converted.\n * @param   {string}    id        The alias of the unique ID of the object in the array.\n * @param   {string}    parentId       The alias of the parent ID of the object in the array.\n * @param   {string}    children  The alias of children of the object in the array.\n * @return  {array}    Return a tree-structured array.\n */\n\nexport function arrayToTree(array, id = 'id', parentId = 'pid', children = 'children') {\n  const result = [];\n  const hash = {};\n  const data = cloneDeep(array);\n  data.forEach((item, index) => {\n    hash[data[index][id]] = data[index];\n  });\n  data.forEach(item => {\n    const hashParent = hash[item[parentId]];\n\n    if (hashParent) {\n      !hashParent[children] && (hashParent[children] = []);\n      hashParent[children].push(item);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n}\n/**\n * Whether the path matches the regexp if the language prefix is ignored, https://github.com/pillarjs/path-to-regexp.\n * @param   {string|regexp|array}     regexp     Specify a string, array of strings, or a regular expression.\n * @param   {string}                  pathname   Specify the pathname to match.\n * @return  {array|null}              Return the result of the match or null.\n */\n\nexport function pathMatchRegexp(regexp, pathname) {\n  return pathToRegexp.pathToRegexp(regexp).exec(pathname);\n}\n/**\n * In an array of objects, specify an object that traverses the objects whose parent ID matches.\n * @param   {array}     array     The Array need to Converted.\n * @param   {string}    current   Specify the object that needs to be queried.\n * @param   {string}    parentId  The alias of the parent ID of the object in the array.\n * @param   {string}    id        The alias of the unique ID of the object in the array.\n * @return  {array}    Return a key array.\n */\n\nexport function queryAncestors(array, current, parentId, id = 'id') {\n  const result = [current];\n  const hashMap = new Map();\n  array.forEach(item => hashMap.set(item[id], item));\n\n  const getPath = current => {\n    const currentParentId = hashMap.get(current[id])[parentId];\n\n    if (currentParentId) {\n      result.push(hashMap.get(currentParentId));\n      getPath(hashMap.get(currentParentId));\n    }\n  };\n\n  getPath(current);\n  return result;\n}\nexport function getResponseError(data) {\n  if (!data) {\n    return '';\n  }\n\n  if (Array.isArray(data.message)) {\n    const item = data.message[0];\n\n    if (!item.constraints) {\n      return data.error || 'Bad request!';\n    }\n\n    return Object.values(item.constraints)[0];\n  } // TODO - parse for langauge or others\n\n\n  return typeof data.message === 'string' ? data.message : 'Bad request!';\n}\nexport function validateUsername(text) {\n  return /^[a-zA-Z0-9]+$/.test(text);\n}\nexport function downloadCsv(url, filename) {\n  let promise = new Promise(async (resolve, reject) => {\n    let xhr = new XMLHttpRequest();\n\n    xhr.onload = () => {\n      let blob = new Blob([xhr.response], {\n        type: 'text/csv'\n      });\n      let href = URL.createObjectURL(blob);\n      let a = document.createElement('a');\n      a.href = href;\n      a.setAttribute('download', filename);\n      a.click();\n      URL.revokeObjectURL(href);\n      resolve({\n        success: true\n      });\n    };\n\n    xhr.onerror = err => {\n      reject(err);\n    };\n\n    xhr.open('GET', url);\n    xhr.setRequestHeader('Authorization', authService.getToken());\n    xhr.responseType = 'blob';\n    xhr.send();\n  });\n  return promise;\n}","map":null,"metadata":{},"sourceType":"module"}