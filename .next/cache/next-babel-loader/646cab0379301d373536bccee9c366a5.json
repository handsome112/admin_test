{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { cloneDeep } from 'lodash';\nimport * as pathToRegexp from 'path-to-regexp';\nimport { authService } from '@services/index';\n/**\n * Convert an array to a tree-structured array.\n * @param   {array}     array     The Array need to Converted.\n * @param   {string}    id        The alias of the unique ID of the object in the array.\n * @param   {string}    parentId       The alias of the parent ID of the object in the array.\n * @param   {string}    children  The alias of children of the object in the array.\n * @return  {array}    Return a tree-structured array.\n */\n\nexport function arrayToTree(array) {\n  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'id';\n  var parentId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'pid';\n  var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'children';\n  var result = [];\n  var hash = {};\n  var data = cloneDeep(array);\n  data.forEach(function (item, index) {\n    hash[data[index][id]] = data[index];\n  });\n  data.forEach(function (item) {\n    var hashParent = hash[item[parentId]];\n\n    if (hashParent) {\n      !hashParent[children] && (hashParent[children] = []);\n      hashParent[children].push(item);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n}\n/**\n * Whether the path matches the regexp if the language prefix is ignored, https://github.com/pillarjs/path-to-regexp.\n * @param   {string|regexp|array}     regexp     Specify a string, array of strings, or a regular expression.\n * @param   {string}                  pathname   Specify the pathname to match.\n * @return  {array|null}              Return the result of the match or null.\n */\n\nexport function pathMatchRegexp(regexp, pathname) {\n  return pathToRegexp.pathToRegexp(regexp).exec(pathname);\n}\n/**\n * In an array of objects, specify an object that traverses the objects whose parent ID matches.\n * @param   {array}     array     The Array need to Converted.\n * @param   {string}    current   Specify the object that needs to be queried.\n * @param   {string}    parentId  The alias of the parent ID of the object in the array.\n * @param   {string}    id        The alias of the unique ID of the object in the array.\n * @return  {array}    Return a key array.\n */\n\nexport function queryAncestors(array, current, parentId) {\n  var id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'id';\n  var result = [current];\n  var hashMap = new Map();\n  array.forEach(function (item) {\n    return hashMap.set(item[id], item);\n  });\n\n  var getPath = function getPath(current) {\n    var currentParentId = hashMap.get(current[id])[parentId];\n\n    if (currentParentId) {\n      result.push(hashMap.get(currentParentId));\n      getPath(hashMap.get(currentParentId));\n    }\n  };\n\n  getPath(current);\n  return result;\n}\nexport function getResponseError(data) {\n  if (!data) {\n    return '';\n  }\n\n  if (Array.isArray(data.message)) {\n    var item = data.message[0];\n\n    if (!item.constraints) {\n      return data.error || 'Bad request!';\n    }\n\n    return Object.values(item.constraints)[0];\n  } // TODO - parse for langauge or others\n\n\n  return typeof data.message === 'string' ? data.message : 'Bad request!';\n}\nexport function validateUsername(text) {\n  return /^[a-zA-Z0-9]+$/.test(text);\n}\nexport function downloadCsv(url, filename) {\n  var promise = new Promise( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {\n      var xhr;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              xhr = new XMLHttpRequest();\n\n              xhr.onload = function () {\n                var blob = new Blob([xhr.response], {\n                  type: 'text/csv'\n                });\n                var href = URL.createObjectURL(blob);\n                var a = document.createElement('a');\n                a.href = href;\n                a.setAttribute('download', filename);\n                a.click();\n                URL.revokeObjectURL(href);\n                resolve({\n                  success: true\n                });\n              };\n\n              xhr.onerror = function (err) {\n                reject(err);\n              };\n\n              xhr.open('GET', url);\n              xhr.setRequestHeader('Authorization', authService.getToken());\n              xhr.responseType = 'blob';\n              xhr.send();\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n  return promise;\n}","map":null,"metadata":{},"sourceType":"module"}